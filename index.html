<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>つまらないお世話ゲーム - 報われない100連続</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      margin: 0;
      padding: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at top, #fce3ff, #f7f0ff 40%, #ffe8d1 100%);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
        "Hiragino Sans", "Yu Gothic", "Noto Sans JP", sans-serif;
    }

    .game-container {
      position: relative;
      width: min(460px, 100% - 24px);
      background: #ffffff;
      border-radius: 22px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.16);
      padding: 18px 18px 20px;
      box-sizing: border-box;
      overflow: hidden;
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .title {
      font-size: 1.05rem;
      font-weight: 700;
      color: #4a374f;
    }

    .subtitle {
      font-size: 0.75rem;
      color: #7c6a82;
      margin-top: 2px;
    }

    .stage-badge {
      font-size: 0.78rem;
      padding: 4px 10px;
      border-radius: 999px;
      background: #f3f0ff;
      color: #4b3f72;
      white-space: nowrap;
    }

    .character-area {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 6px 0 10px;
    }

    #character {
      width: 120px;
      height: 120px;
      position: relative;
      margin-bottom: 6px;
      transition: all 0.4s ease;
    }

    .egg {
      background: radial-gradient(circle at 30% 20%, #ffffff, #ffd6f5);
      border-radius: 50%;
      border: 4px solid #ffb3e6;
    }

    .larva {
      background: #c5f3ff;
      border-radius: 60% 40% 70% 30%;
      border: 4px solid #8cd3e6;
      transform: rotate(-5deg);
    }

    .pupa {
      background: #fce8b2;
      border-radius: 30% 70% 40% 60%;
      border: 4px dashed #f4b400;
      transform: rotate(7deg);
    }

    .weird-base {
      border-radius: 40% 60% 60% 40%;
      border: 4px solid #555;
      transform: rotate(-12deg) scale(1.05);
    }

    .ending-strict {
      background: conic-gradient(
        from 45deg,
        #d0d0d0,
        #b0b0ff,
        #e0e0e0,
        #b0b0ff,
        #d0d0d0
      );
    }

    .ending-balance {
      background: conic-gradient(
        from 45deg,
        #ffd1dc,
        #c4e3ff,
        #ffe9b3,
        #d9ffbf,
        #ffd1dc
      );
    }

    .ending-fun {
      background: conic-gradient(
        from 45deg,
        #ffe6b3,
        #ffb3d9,
        #ffe6b3,
        #ffb3d9,
        #ffe6b3
      );
    }

    .face {
      position: absolute;
      top: 52%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
    }

    .eye {
      width: 10px;
      height: 10px;
      background: #333;
      border-radius: 50%;
      display: inline-block;
      margin: 0 6px;
    }

    .mouth {
      width: 26px;
      height: 14px;
      border-bottom: 3px solid #333;
      border-radius: 0 0 26px 26px;
      margin: 6px auto 0;
    }

    .mouth.weird-mouth {
      border-bottom: none;
      border-top: 3px solid #333;
      border-radius: 26px 26px 0 0;
      transform: rotate(-10deg);
    }

    .progress-bar {
      width: 100%;
      height: 10px;
      background: #f0f0f5;
      border-radius: 999px;
      overflow: hidden;
      margin-bottom: 3px;
    }

    .progress-fill {
      height: 100%;
      width: 0;
      background: linear-gradient(90deg, #ff9ad5, #ffc46b);
      transition: width 0.3s ease;
    }

    .progress-text {
      font-size: 0.8rem;
      text-align: right;
      margin-bottom: 6px;
      color: #776f8a;
    }

    .task-box {
      background: #faf7ff;
      border-radius: 14px;
      padding: 10px 12px;
      margin-bottom: 8px;
    }

    .task-label {
      font-size: 0.78rem;
      opacity: 0.7;
      margin-bottom: 2px;
      color: #7a6a8a;
    }

    .task-text {
      font-size: 0.95rem;
      line-height: 1.4;
      color: #403445;
    }

    .mini-hint {
      font-size: 0.76rem;
      color: #9a879f;
      margin-top: 4px;
    }

    .buttons {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-bottom: 4px;
      margin-top: 2px;
    }

    .buttons button {
      border: none;
      border-radius: 999px;
      padding: 8px 12px;
      font-size: 0.9rem;
      cursor: pointer;
      background: #f0ebff;
      text-align: left;
      transition: transform 0.05s ease, box-shadow 0.05s ease,
        background 0.15s ease, opacity 0.15s ease;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .buttons button:nth-child(1) { background: #ffe4f5; }
    .buttons button:nth-child(2) { background: #fff5d9; }
    .buttons button:nth-child(3) { background: #e7ffe1; }

    .buttons button:hover:enabled {
      transform: translateY(-1px);
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.15);
    }

    .buttons button:active:enabled {
      transform: translateY(0);
      box-shadow: none;
    }

    .buttons.disabled button {
      opacity: 0.5;
      cursor: default;
      box-shadow: none;
    }

    .log-line {
      font-size: 0.75rem;
      min-height: 1.1em;
      color: #7b748e;
      margin-bottom: 4px;
    }

    .result {
      margin-top: 6px;
      font-size: 0.85rem;
      color: #4a445e;
    }

    .hidden {
      display: none;
    }

    .restart-btn {
      margin-top: 10px;
      border-radius: 999px;
      border: none;
      padding: 8px 12px;
      font-size: 0.85rem;
      background: #ece6ff;
      cursor: pointer;
      display: inline-block;
      margin-right: 6px;
    }

    .share-btn {
      background: #ffe4f1;
    }

    footer {
      margin-top: 6px;
      text-align: center;
      font-size: 0.7rem;
      opacity: 0.6;
      color: #6b647c;
    }

    /* ミニゲーム用オーバーレイ */
    .mini-overlay {
      position: absolute;
      inset: 0;
      background: rgba(255, 255, 255, 0.92);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 5;
    }

    .mini-card {
      width: 100%;
      max-width: 360px;
      background: #fffdfb;
      border-radius: 16px;
      border: 1px solid #ffe0bf;
      padding: 10px 12px;
      box-sizing: border-box;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.06);
    }

    .mini-title {
      font-size: 0.95rem;
      font-weight: 700;
      margin-bottom: 2px;
      color: #7a4a1a;
    }

    .mini-caption {
      font-size: 0.78rem;
      color: #9a6a32;
      margin-bottom: 4px;
    }

    .mini-area {
      position: relative;
      width: 100%;
      height: 140px;
      background: #fff3e0;
      border-radius: 12px;
      overflow: hidden;
      margin-bottom: 6px;
      touch-action: none;
    }

    .mini-item {
      position: absolute;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: #ffb3c6;
      box-shadow: 0 0 4px rgba(0,0,0,0.15);
    }

    #mini-catcher {
      position: absolute;
      bottom: 6px;
      width: 40px;
      height: 10px;
      border-radius: 10px;
      background: #ff8b3d;
    }

    .mini-footer {
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: 0.8rem;
      color: #7a5a34;
      margin-top: 4px;
    }

    .mini-footer button {
      border-radius: 999px;
      border: none;
      padding: 6px 12px;
      font-size: 0.8rem;
      cursor: pointer;
      background: #ffd9b3;
    }

    .mini-timer {
      font-feature-settings: "tnum";
    }

    .mini-counter {
      font-size: 0.78rem;
      margin-left: 4px;
      opacity: 0.8;
    }
  </style>
</head>
<body>
  <div class="game-container">
    <header>
      <div>
        <div class="title">つまらないお世話ゲーム</div>
        <div class="subtitle">報われないお世話を100個こなすだけの装置</div>
      </div>
      <div class="stage-badge" id="stage-label">たまごステージ</div>
    </header>

    <div class="character-area">
      <div id="character" class="egg">
        <div class="face">
          <div class="eye"></div>
          <div class="eye"></div>
          <div class="mouth" id="mouth"></div>
        </div>
      </div>
      <div class="progress-bar">
        <div class="progress-fill" id="progress-fill"></div>
      </div>
      <div class="progress-text" id="progress-text">0 / 100</div>
    </div>

    <div class="task-box" id="task-box">
      <div class="task-label" id="task-label">No.1 のお世話</div>
      <div class="task-text" id="task-text"></div>
      <div class="mini-hint">まずは、なんとなくミニゲームでお世話してみてください。</div>
    </div>

    <div class="buttons" id="buttons">
      <button data-score="0">
        これはつまらない
        <span style="font-size:0.75rem;opacity:0.7;">（いい意味で）</span>
      </button>
      <button data-score="1">
        まあつまらない
      </button>
      <button data-score="2">
        意外と好きかもしれない
      </button>
    </div>

    <div class="log-line" id="log-line"></div>
    <div class="result hidden" id="result"></div>

    <!-- ミニゲームオーバーレイ -->
    <div class="mini-overlay" id="mini-overlay">
      <div class="mini-card">
        <div class="mini-title">ミニお世話ゲーム</div>
        <div class="mini-caption" id="mini-caption">
          今回のお世話を、なんとなく5秒だけシミュレートしてみます。
        </div>
        <div class="mini-area" id="mini-area">
          <div id="mini-catcher"></div>
        </div>
        <div class="mini-footer">
          <div>
            のこり <span class="mini-timer" id="mini-timer">5.0</span> 秒
            <span class="mini-counter" id="mini-counter">とれた数：0</span>
          </div>
          <div>
            <button id="mini-start-btn">スタート</button>
            <button id="mini-ok-btn" class="hidden">OK</button>
          </div>
        </div>
      </div>
    </div>

    <footer>1つゲーム → ジャッジ → 次のお世話へ。100個終わると変なキャラが完成します。</footer>
  </div>

  <script>
    const TOTAL_TASKS = 100;

    const tasks = [
      "スマホの充電残量を毎朝チェックする（見ても充電は増えない）",
      "観葉植物の葉っぱのほこりをふく（すぐにまた積もる）",
      "使っていないアプリの通知をオフにする（誰も気づかない）",
      "冷蔵庫の賞味期限シールをながめて確認する（見るだけで減らない）",
      "リモコンをきれいに並べ直す（すぐ誰かがずらす）",
      "ティッシュの箱を部屋ごとにそろえる（誰も感謝しない）",
      "水筒のパッキンを毎回ちゃんとはめる（達成感はゼロ）",
      "えんぴつを一本だけきれいにけずる（特に使われない）",
      "いらないレシートを一枚だけ捨てる（財布はまだパンパン）",
      "カバンの中のごみを一個だけ捨てる（劇的には変わらない）",
      "机の上のものを右から左へ並べ替える（意味はあまりない）",
      "カーテンのしわを手でのばす（またしわが寄る）",
      "ゴミ箱のビニール袋をぴしっと広げる（誰も見ていない）",
      "コンセントまわりのほこりをちょっとだけ取る（世界はあまり変わらない）",
      "ハンカチをきれいに四つ折りにたたむ（すぐポケットの中でぐちゃぐちゃ）",
      "リップクリームのふたをそっと閉める（音が静かなだけ）",
      "消しゴムのカスを集めて丸める（丸めたカスはすぐ捨てられる）",
      "ペン立てのペンを色順にならべる（誰も気づかないグラデーション）",
      "毎朝、時計を一回だけ見て「ふーん」と思う（特に何も変わらない）",
      "カレンダーの日付に小さく〇をつける（つけても予定は増えない）",
      "マグカップの取っ手の向きをそろえる（使うとすぐバラバラ）",
      "イスを机にきちんとしまう（またすぐ出される）",
      "靴を玄関でつま先そろえて並べる（すぐに誰かが崩す）",
      "ブランケットの向きをきれいに直す（寝たらまたずれる）",
      "リュックのチャックを全部しめる確認をする（誰も見ていない安全確認）",
      "テレビの音量をいつもの数字に戻す（こだわりは自分だけ）",
      "部屋のスイッチを全部オフか確認する（オンにするのも自分）",
      "えんぴつの芯の長さをそろえようとしてみる（完璧にはそろわない）",
      "ノートの角をきちんと合わせてそろえる（またすぐずれる）",
      "メガネ拭きでメガネを一拭きだけする（世界の見え方はあまり変わらない）",
      "テーブルの上を手のひらでさっとなでてゴミを集める（集めてもすぐ落ちる）",
      "プリントの端をそろえてトントンする（自己満足の整列）",
      "ポケットに何も入っていないか確認する（ほぼ毎回何も入っていない）",
      "マスクの予備を一枚だけカバンに入れておく（使われないままくしゃくしゃ）",
      "スマホ画面の指紋をちょっとだけふく（すぐまたつく）",
      "お気に入りサイトのタブを閉じずに並べ直す（結局全部見るわけではない）",
      "充電ケーブルをくるっと巻いておきなおす（次に使うときまたほどく）",
      "鍵の位置を毎回同じ場所に戻す（それでもたまに見失う）",
      "同じペンで今日の日付だけ書いてみる（誰もそのこだわりに気づかない）",
      "ごみの日かどうかだけカレンダーで確認する（確認しても出し忘れる時がある）",
      "使っていないノートの一枚目だけめくって戻す（特に意味はない）",
      "プリントのクリアファイルを色ごとに分けてみる（使うときは結局全部開ける）",
      "洗面台の水しぶきを指でなでて消す（数分後にはまた水しぶき）",
      "イスの高さをちょっとだけ調整する（違いはほとんど分からない）",
      "スリッパをそろえてスタートラインを作る（誰もそのラインを意識しない）",
      "ティッシュを一枚だけ予備でポケットに入れる（存在を忘れられる）",
      "お気に入りのシャーペンだけ芯を補充する（今日は別のペンを使う）",
      "机の角とノートの角をぴったり合わせて置く（すぐずれる）",
      "部屋の時計とスマホの時間を見比べる（ほぼ同じことを確認するだけ）",
      "SNSの通知マークを全部消してゼロにする（すぐにまた1件つく）",
      "冷蔵庫の中のペットボトルの向きをそろえる（誰も気にしない整列）",
      "ペンのキャップがちゃんとはまっているか確認する（はまっていても安心感だけ）",
      "えんぴつの名前シールがはがれてないか見る（見ても特に何もしない）",
      "プリントの穴あけ位置を揃えてながめる（見た目がちょっと気持ちいいだけ）",
      "洗濯物のハンガーの向きをそろえる（風が吹いたら終わり）",
      "今日使わない文房具をペンケースから一個出しておく（たぶん明日も使わない）",
      "お気に入りのスタンプを一つだけ押して満足する（誰もその1個に気づかない）",
      "スマホのホーム画面のアイコンを一個だけ移動する（配置はほとんど変わらない）",
      "教科書に付箋を一枚だけ貼りかえる（たぶんそこも読まない）",
      "カーテンの開き具合を左右対称にととのえる（誰も参加しないシンメトリー）",
      "椅子の下に何も落ちていないかのぞきこむ（見つけても拾うのは自分）",
      "えんぴつの長さ順に並べてニヤッとする（すぐに順番がぐちゃぐちゃ）",
      "ペットボトルのラベルをまっすぐに戻す（またすぐずれる）",
      "カバンの中でペンケースの位置を決める（揺れると元どおり）",
      "上着のファスナーを一番上まで上げてみる（すぐ下ろす）",
      "机の引き出しを一回だけ開けて何もせず閉める（安心感だけ増える）",
      "お気に入り消しゴムの角を一つだけ使ってみる（誰もその角の変化に気づかない）",
      "水道のレバーをまっすぐな角度にそろえる（次の人がすぐ動かす）",
      "トイレットペーパーの先端を三角に折る（芸術点だけが上がる）",
      "メモ帳の表紙をなでてからカバンに入れる（なでられたことは忘れられる）",
      "リモコンの向きをテレビにぴったり揃えて置く（使えばすぐズレる）",
      "つめきりを決まった場所に戻すだけの仕事（誰も気づかない秩序）",
      "USBメモリのキャップをなくしてないか確認する（なくしてからでは遅い）",
      "カギ束のキーホルダーの向きを整える（本人以外は見ていない）",
      "今日使わないカードを財布の奥にしまいなおす（また別の日に迷う）",
      "鏡の前で前髪を一回だけ直す（外に出たら風で終わり）",
      "椅子の足を全部同じ線の上にそろえる（誰もそのラインに気づかない）",
      "スマホの画面の明るさをいつもの明るさに調整する（微妙な差）",
      "使いかけのノートのしおりをきれいに差しなおす（次開くまで誰も知らない）",
      "机の上の本のタイトルが読める向きにそろえる（誰も読まないかもしれない）",
      "タオルをくるっと巻いて同じ高さにそろえる（すぐ使って崩れる）",
      "カーテンのタッセルをきれいな位置に直す（ちょっとだけ満足）",
      "ごみ袋の口をきゅっと結び直すだけ（結び直しても中身は同じ）",
      "洗面台のコップをまっすぐの向きに置く（すぐ誰かが回す）",
      "ハンドクリームを手の甲に一回だけ塗る（世界はあまり変わらない）",
      "使い終わったイスを元の場所にぴったり戻す（またすぐ動かされる）",
      "机の下の足元マットの向きを直す（動くたびにずれる）",
      "充電器のコンセントを根元までしっかり差しこむ（もともと刺さっていることが多い）",
      "ホワイトボードのペンを色順に置き直す（授業で順番は崩れる）",
      "今日のプリントを一枚だけファイルにしまう（その1枚だけ妙に丁寧）",
      "教科書の角が折れていたらそっとのばす（またすぐ折れる）",
      "使い終わったお皿をシンクの端にきれいに重ねる（洗うのはまだ先）",
      "ペットボトルのキャップを集めて同じ場所に入れる（特に使い道は決まっていない）",
      "折りたたみ傘のヒモをちゃんと巻き直す（次に使うとき急いでほどく）",
      "ポケットティッシュの残り枚数をなんとなく確認する（確認しても増えない）",
      "イスの背もたれにかけた上着のしわをのばす（座ったらまたしわ）",
      "机の上の充電コードを一本だけほどいて整える（すぐ絡まる）",
      "電気を消す前に部屋を一回見回す（特に変化はない）",
      "寝る前に枕の位置をちょっとだけ中央に直す（寝返りですぐズレる）",
      "「今日もなんか世話したな」と小さく思いながら寝る（誰も知らない満足感）"
    ];

    const characterEl = document.getElementById("character");
    const mouthEl = document.getElementById("mouth");
    const stageLabelEl = document.getElementById("stage-label");
    const progressFillEl = document.getElementById("progress-fill");
    const progressTextEl = document.getElementById("progress-text");
    const taskLabelEl = document.getElementById("task-label");
    const taskTextEl = document.getElementById("task-text");
    const buttonsEl = document.getElementById("buttons");
    const logLineEl = document.getElementById("log-line");
    const resultEl = document.getElementById("result");

    const miniOverlayEl = document.getElementById("mini-overlay");
    const miniAreaEl = document.getElementById("mini-area");
    const miniCatcherEl = document.getElementById("mini-catcher");
    const miniTimerEl = document.getElementById("mini-timer");
    const miniCounterEl = document.getElementById("mini-counter");
    const miniCaptionEl = document.getElementById("mini-caption");
    const miniStartBtn = document.getElementById("mini-start-btn");
    const miniOkBtn = document.getElementById("mini-ok-btn");

    let currentIndex = 0;
    const ratings = [];
    let miniPlayedForThisTask = false;

    // ミニゲーム状態
    let miniPlaying = false;
    let miniStartTime = 0;
    const miniDuration = 5000;
    let miniTimerInterval = null;
    let miniGameInterval = null;
    let miniItems = [];
    let miniCaught = 0;
    let catcherX = 0;

    function getStage(completed) {
      if (completed < 10) return "egg";
      if (completed < 20) return "larva";
      if (completed < TOTAL_TASKS) return "pupa";
      return "weird";
    }

    function getStageLabel(stage) {
      if (stage === "egg") return "たまごステージ";
      if (stage === "larva") return "幼虫ステージ（不細工）」";
      if (stage === "pupa") return "さなぎステージ（よく分からない形）";
      return "へんなキャラステージ（コンプリート）";
    }

    function updateCharacterStage(stage) {
      characterEl.className = stage;
      if (stage === "weird") {
        mouthEl.classList.add("weird-mouth");
      } else {
        mouthEl.classList.remove("weird-mouth");
      }
      stageLabelEl.textContent = getStageLabel(stage);
    }

    function updateProgress() {
      const completed = currentIndex;
      const percentage = (completed / TOTAL_TASKS) * 100;
      progressFillEl.style.width = percentage + "%";
      progressTextEl.textContent = completed + " / " + TOTAL_TASKS;
    }

    function updateTask() {
      const no = currentIndex + 1;
      taskLabelEl.textContent = "No." + no + " のお世話";
      taskTextEl.textContent = tasks[currentIndex];

      miniCaptionEl.textContent =
        "「" + tasks[currentIndex].split("（")[0] +
        "」を、よく分からない落ちものゲームで5秒だけ再現してみます。";
    }

    function setButtonsEnabled(enabled) {
      if (enabled) {
        buttonsEl.classList.remove("disabled");
      } else {
        buttonsEl.classList.add("disabled");
      }
      buttonsEl.querySelectorAll("button").forEach(btn => {
        btn.disabled = !enabled;
      });
    }

    function showEvolutionMessage(stage) {
      if (stage === "larva") {
        logLineEl.textContent =
          "10個クリア！たまごが、不細工な幼虫になった…。";
      } else if (stage === "pupa") {
        logLineEl.textContent =
          "20個クリア！幼虫が、見たことない形のさなぎになった…。";
      } else if (stage === "weird") {
        logLineEl.textContent =
          "100個コンプリート！さなぎが、よくわからない変なキャラクターになった！";
      } else {
        logLineEl.textContent = "";
      }
    }

    function showLastRatingMessage(score) {
      if (score === 0) {
        logLineEl.textContent = "「これはつまらない」とジャッジしました。";
      } else if (score === 1) {
        logLineEl.textContent = "「まあつまらない」とジャッジしました。";
      } else if (score === 2) {
        logLineEl.textContent = "「意外と好きかもしれない」とジャッジしました。";
      }
    }

    function decideEndingType(count0, count1, count2) {
      if (count0 >= 50 && count0 >= count2) {
        return "strict";
      } else if (count2 >= 50 && count2 > count0) {
        return "fun";
      } else {
        return "balance";
      }
    }

    function getEndingText(type) {
      if (type === "strict") {
        return {
          title: "枯れる花タイプ",
          desc: "つまらないお世話をきっちりジャッジして、どんな小さな違和感も見逃さない職人肌。水をあげても必ず枯れる花のように、「報われなさ」を観察するのが得意なキャラです。"
        };
      } else if (type === "fun") {
        return {
          title: "気まぐれ金魚タイプ",
          desc: "意味のなさそうなお世話の中にも、ちょっとした楽しさやユーモアを見つけてしまう気まぐれキャラ。餌をあげても元気にならない金魚のように、理屈ではない世界を楽しんでいます。"
        };
      } else {
        return {
          title: "隠れるウサギタイプ",
          desc: "報われないお世話も、少し距離をとりながら眺めているバランスタイプ。近づくと隠れてしまうウサギのように、近すぎず遠すぎないところから生活の『くだらなさ』を味わっています。"
        };
      }
    }

    function applyEndingAppearance(type) {
      characterEl.className = "weird-base";
      if (type === "strict") {
        characterEl.classList.add("ending-strict");
      } else if (type === "fun") {
        characterEl.classList.add("ending-fun");
      } else {
        characterEl.classList.add("ending-balance");
      }
      mouthEl.classList.add("weird-mouth");
      stageLabelEl.textContent = getStageLabel("weird");
    }

    function copyTextToClipboard(text) {
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(text).then(() => {
          logLineEl.textContent =
            "結果をコピーしました。アンケートやメモに貼り付けてください。";
        }).catch(() => {
          logLineEl.textContent =
            "コピーに失敗しました。テキストを手動で選択してコピーしてください。";
        });
      } else {
        const textarea = document.createElement("textarea");
        textarea.value = text;
        document.body.appendChild(textarea);
        textarea.select();
        try {
          document.execCommand("copy");
          logLineEl.textContent =
            "結果をコピーしました。アンケートやメモに貼り付けてください。";
        } catch (e) {
          logLineEl.textContent =
            "コピーに失敗しました。テキストを手動で選択してコピーしてください。";
        }
        document.body.removeChild(textarea);
      }
    }

    function showFinalResult() {
      document.getElementById("task-box").classList.add("hidden");
      buttonsEl.classList.add("hidden");
      miniOverlayEl.classList.add("hidden");
      resultEl.classList.remove("hidden");

      let count0 = 0, count1 = 0, count2 = 0;
      ratings.forEach(v => {
        if (v === 0) count0++;
        if (v === 1) count1++;
        if (v === 2) count2++;
      });

      const endingType = decideEndingType(count0, count1, count2);
      const endingInfo = getEndingText(endingType);
      applyEndingAppearance(endingType);

      const shareText =
`つまらないお世話ゲーム（報われない100連続）結果
「これはつまらない」: ${count0}
「まあつまらない」: ${count1}
「意外と好きかもしれない」: ${count2}
タイプ: ${endingInfo.title}`;

      resultEl.innerHTML =
        "<p>100個ぜんぶジャッジしました。</p>" +
        "<p>つまらない度の内訳：</p>" +
        "<ul style='padding-left:1.2em; margin-top:4px; margin-bottom:4px;'>" +
        "<li>「これはつまらない」：" + count0 + " 個</li>" +
        "<li>「まあつまらない」：" + count1 + " 個</li>" +
        "<li>「意外と好きかもしれない」：" + count2 + " 個</li>" +
        "</ul>" +
        "<p><strong>あなたの変なキャラ診断：</strong></p>" +
        "<p><strong>" + endingInfo.title + "</strong></p>" +
        "<p>" + endingInfo.desc + "</p>" +
        "<p>このキャラは、あなたが選び続けた「くだらない・報われないお世話」から生まれました。</p>" +
        "<button class='restart-btn' id='restart-btn'>もう一度はじめから</button>" +
        "<button class='restart-btn share-btn' id='copy-btn'>結果をコピー</button>";

      const restartBtn = document.getElementById("restart-btn");
      restartBtn.addEventListener("click", restartGame);

      const copyBtn = document.getElementById("copy-btn");
      copyBtn.addEventListener("click", () => {
        copyTextToClipboard(shareText);
      });
    }

    function restartGame() {
      currentIndex = 0;
      ratings.length = 0;
      miniPlayedForThisTask = false;
      stopMiniGame();
      resultEl.classList.add("hidden");
      document.getElementById("task-box").classList.remove("hidden");
      buttonsEl.classList.remove("hidden");
      logLineEl.textContent = "";
      characterEl.className = "egg";
      mouthEl.classList.remove("weird-mouth");
      stageLabelEl.textContent = getStageLabel("egg");
      updateUI();
    }

    function handleRating(score) {
      if (!miniPlayedForThisTask) {
        logLineEl.textContent =
          "まずはミニゲームで、なんとなくお世話してみてください。";
        openMiniOverlay();
        return;
      }

      const completedBefore = currentIndex;
      ratings[currentIndex] = score;
      currentIndex++;

      const completedAfter = currentIndex;
      const oldStage = getStage(completedBefore);
      const newStage = getStage(completedAfter);

      miniPlayedForThisTask = false;
      updateUI();

      if (completedAfter >= TOTAL_TASKS) {
        showEvolutionMessage("weird");
        showFinalResult();
        return;
      }

      if (newStage !== oldStage) {
        showEvolutionMessage(newStage);
      } else {
        showLastRatingMessage(score);
      }
    }

    function updateUI() {
      const stage = getStage(currentIndex);
      updateCharacterStage(stage);
      updateProgress();

      if (currentIndex < TOTAL_TASKS) {
        updateTask();
        openMiniOverlay();
      }
    }

    // ミニゲーム関連
    function resetMiniGameView() {
      miniPlaying = false;
      miniStartTime = 0;
      miniItems.forEach(it => {
        if (it.el.parentNode === miniAreaEl) {
          miniAreaEl.removeChild(it.el);
        }
      });
      miniItems = [];
      miniCaught = 0;
      miniTimerEl.textContent = "5.0";
      miniCounterEl.textContent = "とれた数：0";
      miniStartBtn.classList.remove("hidden");
      miniOkBtn.classList.add("hidden");
      miniStartBtn.disabled = false;

      const rect = miniAreaEl.getBoundingClientRect();
      catcherX = rect.width / 2;
      miniCatcherEl.style.left = (catcherX - 20) + "px";
    }

    function stopMiniGame() {
      miniPlaying = false;
      if (miniTimerInterval) {
        clearInterval(miniTimerInterval);
        miniTimerInterval = null;
      }
      if (miniGameInterval) {
        clearInterval(miniGameInterval);
        miniGameInterval = null;
      }
      miniItems.forEach(it => {
        if (it.el.parentNode === miniAreaEl) {
          miniAreaEl.removeChild(it.el);
        }
      });
      miniItems = [];
    }

    function startMiniGame() {
      stopMiniGame();
      miniPlaying = true;
      miniStartTime = performance.now();
      miniCaught = 0;
      miniCounterEl.textContent = "とれた数：0";
      miniStartBtn.disabled = true;

      miniTimerInterval = setInterval(() => {
        const elapsed = performance.now() - miniStartTime;
        const remain = Math.max(0, (miniDuration - elapsed) / 1000);
        miniTimerEl.textContent = remain.toFixed(1);
        if (elapsed >= miniDuration) {
          endMiniGame();
        }
      }, 100);

      miniGameInterval = setInterval(updateMiniGame, 30);
    }

    function endMiniGame() {
      if (!miniPlaying) return;
      stopMiniGame();
      miniStartBtn.classList.add("hidden");
      miniOkBtn.classList.remove("hidden");
      miniCaptionEl.textContent =
        "ミニゲーム終了。たくさん取れても取れなくても、現実世界はあまり変わりません。";
    }

    function updateMiniGame() {
      const areaRect = miniAreaEl.getBoundingClientRect();
      const catcherWidth = 40;
      const catcherY = areaRect.height - 6 - 10;

      if (Math.random() < 0.12) {
        const itemEl = document.createElement("div");
        itemEl.className = "mini-item";
        const x = Math.random() * (areaRect.width - 14) + 7;
        const y = -14;
        itemEl.style.left = (x - 7) + "px";
        itemEl.style.top = y + "px";
        miniAreaEl.appendChild(itemEl);
        miniItems.push({ x, y, el: itemEl });
      }

      const speed = 3;
      const newItems = [];
      miniItems.forEach(obj => {
        obj.y += speed;
        if (obj.y > areaRect.height + 20) {
          miniAreaEl.removeChild(obj.el);
          return;
        }

        const dx = obj.x - catcherX;
        if (obj.y >= catcherY - 10 && Math.abs(dx) < catcherWidth / 2 + 4) {
          miniCaught += 1;
          miniCounterEl.textContent = "とれた数：" + miniCaught;
          miniAreaEl.removeChild(obj.el);
          return;
        }

        obj.el.style.top = obj.y + "px";
        newItems.push(obj);
      });
      miniItems = newItems;

      miniCatcherEl.style.left = (catcherX - catcherWidth / 2) + "px";
    }

    function onMiniPointerMove(e) {
      const rect = miniAreaEl.getBoundingClientRect();
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      let x = clientX - rect.left;
      x = Math.max(20, Math.min(rect.width - 20, x));
      catcherX = x;
      const catcherWidth = 40;
      miniCatcherEl.style.left = (catcherX - catcherWidth / 2) + "px";
    }

    function openMiniOverlay() {
      miniOverlayEl.classList.remove("hidden");
      setButtonsEnabled(false);
      resetMiniGameView();
      logLineEl.textContent =
        "ミニお世話ゲームで、今回のお世話をなんとなく体験してからジャッジしてください。";
    }

    miniAreaEl.addEventListener("mousemove", onMiniPointerMove);
    miniAreaEl.addEventListener("touchmove", function(e) {
      onMiniPointerMove(e);
      e.preventDefault();
    }, { passive: false });

    miniStartBtn.addEventListener("click", startMiniGame);

    miniOkBtn.addEventListener("click", () => {
      miniPlayedForThisTask = true;
      miniOverlayEl.classList.add("hidden");
      setButtonsEnabled(true);
      logLineEl.textContent =
        "なんとなくお世話してみましたね。今の感覚で、このお世話のつまらなさをジャッジしてみてください。";
    });

    // 評価ボタン
    buttonsEl.querySelectorAll("button").forEach(btn => {
      btn.addEventListener("click", () => {
        const score = Number(btn.dataset.score);
        handleRating(score);
      });
    });

    updateUI();
  </script>
</body>
</html>
